// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/console.sol";
import "forge-std/Test.sol";

import {TickMath} from "src/TickMath.sol";
import {SwapMath} from "src/SwapMath.sol";
import {FixedSwapMath} from "src/FixedSwapMath.sol";
import {MathConstants as C} from './MathConstants.sol';
import {FullMath} from './FullMath.sol';

contract KyperRoundingError is Test {
    uint256 liquidity;
    uint160 currentSqrtP;
    uint160 targetSqrtP;
    uint256 feeInFeeUnit;
    int256 specifiedAmount;
    bool isExactInput;
    bool isToken0;
    int24 nextTick;

    function setUp() public  {
        // params from attack transaction https://explorer.phalcon.xyz/tx/eth/0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3?line=5010&debugLine=5010
        liquidity = 74694598994958027329; 
        currentSqrtP = 20282409603651670423947251286016;
        targetSqrtP = 20693058119558072255662180724088;
        feeInFeeUnit = 10;
        specifiedAmount = 387170294533119999999;
        isExactInput = true;
        isToken0 = false;
        nextTick = 111310;
    }

    function testRoundingError() public {
        // https://github.com/KyberNetwork/ks-elastic-sc/blob/main/contracts/libraries/SwapMath.sol#L189-L194

        int256 usedAmount = SwapMath.calcReachAmount(liquidity, currentSqrtP, targetSqrtP, feeInFeeUnit, isExactInput, isToken0);
        uint256 absDelta = uint256(usedAmount) - 1;
        console2.log("absDelta", absDelta);

        console2.log("deltaL in FullMath.mulDivFloor", FullMath.mulDivFloor(
            C.TWO_POW_96,
            absDelta * feeInFeeUnit,
            C.TWO_FEE_UNITS * currentSqrtP
          ));

        console2.log("deltaL in FullMath.mulDivCeiling", FullMath.mulDivCeiling(
            C.TWO_POW_96,
            absDelta * feeInFeeUnit,
            C.TWO_FEE_UNITS * currentSqrtP
          ));

        console2.log("------------------------------------------------");

        console2.log("Rounding down:");
        // Calculation results based on KyperSwap SwapMath implementation
        (, , , uint160 nextSqrtP_1) = SwapMath.computeSwapStep(
            liquidity,
            currentSqrtP,
            targetSqrtP,
            feeInFeeUnit,
            specifiedAmount,
            isExactInput,
            isToken0
        );

        console2.log("nextSqrtP_1", nextSqrtP_1);

        console2.log("Is nextSqrtP_1 greater than targetSqrtP?", nextSqrtP_1 > targetSqrtP);

        int24 currentTick_1 = TickMath.getTickAtSqrtRatio(nextSqrtP_1);

        console2.log("currentTick_1", currentTick_1);

        console2.log("Is currentTick_1 equal to nextTick?", currentTick_1 == nextTick);

        console2.log("\t");

        // FixedSwapMath: Modify KyperSwap's SwapMath.estimateIncrementalLiquidity implementation from FullMath.mulDivFloor() to FullMath.mulDivCeiling() 
        // Calculation results based on KyperSwap FixedSwapMath implementation

        console2.log("Rounding up:");
        (, , , uint160 nextSqrtP_2) = FixedSwapMath.computeSwapStep(
            liquidity,
            currentSqrtP,
            targetSqrtP,
            feeInFeeUnit,
            specifiedAmount,
            isExactInput,
            isToken0
        );

        console2.log("nextSqrtP_2", nextSqrtP_2);

        console2.log("Is nextSqrtP_2 greater than targetSqrtP?", nextSqrtP_2 > targetSqrtP);

        int24 currentTick_2 = TickMath.getTickAtSqrtRatio(nextSqrtP_2);

        console2.log("currentTick_2", currentTick_2);

        console2.log("Is currentTick_2 equal to nextTick?", currentTick_2 == nextTick);

    } 

    // inspired by https://github.com/paco0x/kyber-exploit-example
    function testProbability() public {
        uint128 liquidity = 80e18;
        uint256 count = 0;
        uint256 found = 0;
        while (true) {
            liquidity++;
            count++;
            // numbers from TX 0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3
            uint160 currentSqrtP = 20282409603651670423947251286016;
            uint160 targetSqrtP = 20693058119558072255662180724088;
            int256 usedAmount = FixedSwapMath.calcReachAmount(liquidity, currentSqrtP, targetSqrtP, 10, true, false);

            uint256 absDelta = uint256(usedAmount) - 1;
            uint256 deltaL = FixedSwapMath.estimateIncrementalLiquidity(absDelta, liquidity, currentSqrtP, 10, true, false);
            uint160 nextSqrtP = uint160(FixedSwapMath.calcFinalPrice(absDelta, liquidity, deltaL, currentSqrtP, true, false));


            if (nextSqrtP > targetSqrtP) {
                found++;
            }
            if (count == 10_000_000) {
                break;
            }
        }
        console2.log("found", found, "in", 10_000_000);
    }

    // inspired by https://github.com/paco0x/kyber-exploit-example
    function testFuzz(uint128 l) public {
        uint128 liquidity = uint128(bound(l, 65e18, 75e18));
        // numbers from TX 0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3
        uint160 currentSqrtP = 20282409603651670423947251286016;
        uint160 targetSqrtP = 20693058119558072255662180724088;
        int256 usedAmount = FixedSwapMath.calcReachAmount(liquidity, currentSqrtP, targetSqrtP, 10, true, false);

        uint256 absDelta = uint256(usedAmount) - 1;
        uint256 deltaL = FixedSwapMath.estimateIncrementalLiquidity(absDelta, liquidity, currentSqrtP, 10, true, false);
        uint160 nextSqrtP = uint160(FixedSwapMath.calcFinalPrice(absDelta, liquidity, deltaL, currentSqrtP, true, false));

        console2.log("liquidity", liquidity);
        console2.log("targetSqrtP", targetSqrtP);
        console2.log("nextSqrtP", nextSqrtP);

        assertEq(nextSqrtP <= targetSqrtP, true);
    }
}